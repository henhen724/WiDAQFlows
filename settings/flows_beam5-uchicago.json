[{"id":"527caf4af9e659ad","type":"tab","label":"Flow 1","disabled":false,"info":""},{"id":"e0f52056.325bc","type":"ui_group","name":"RPi Zero","tab":"3bec34ab.c27f4c","order":1,"disp":false,"width":"13","collapse":false},{"id":"8e661657.472578","type":"mqtt-broker","name":"Controls server","broker":"beam.uchicago.edu","port":"1883","clientid":"","usetls":false,"compatmode":false,"protocolVersion":"4","keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willPayload":"","willMsg":{},"sessionExpiry":""},{"id":"3bec34ab.c27f4c","type":"ui_tab","name":"Home","icon":"dashboard","disabled":false,"hidden":false},{"id":"dabdd185.14c78","type":"serial-port","serialport":"/dev/rfcomm0","serialbaud":"9600","databits":"8","parity":"none","stopbits":"1","waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\n","bin":"false","out":"char","addchar":"","responsetimeout":"10000"},{"id":"cb445b81.34d848","type":"ui_base","theme":{"name":"theme-light","lightTheme":{"default":"#0094CE","baseColor":"#0094CE","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"darkTheme":{"default":"#097479","baseColor":"#097479","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":false},"customTheme":{"name":"Untitled Theme 1","default":"#4B7930","baseColor":"#4B7930","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"},"themeState":{"base-color":{"default":"#0094CE","value":"#0094CE","edited":false},"page-titlebar-backgroundColor":{"value":"#0094CE","edited":false},"page-backgroundColor":{"value":"#fafafa","edited":false},"page-sidebar-backgroundColor":{"value":"#ffffff","edited":false},"group-textColor":{"value":"#1bbfff","edited":false},"group-borderColor":{"value":"#ffffff","edited":false},"group-backgroundColor":{"value":"#ffffff","edited":false},"widget-textColor":{"value":"#111111","edited":false},"widget-backgroundColor":{"value":"#0094ce","edited":false},"widget-borderColor":{"value":"#ffffff","edited":false},"base-font":{"value":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"}},"angularTheme":{"primary":"indigo","accents":"blue","warn":"red","background":"grey","palette":"light"}},"site":{"name":"Node-RED Dashboard","hideToolbar":"false","allowSwipe":"false","lockMenu":"false","allowTempTheme":"true","dateFormat":"DD/MM/YYYY","sizes":{"sx":48,"sy":48,"gx":6,"gy":6,"cx":6,"cy":6,"px":0,"py":0}}},{"id":"44644766.155948","type":"serial-port","serialport":"/dev/rfcomm1","serialbaud":"9600","databits":"8","parity":"none","stopbits":"1","waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\n","bin":"false","out":"char","addchar":"","responsetimeout":"10000"},{"id":"c73f1334ec7ae6a9","type":"xmlrpc-client","name":"ACNET remote","host":"www-bd.fnal.gov","port":"443","path":"/xmlrpc/Remote"},{"id":"36bfa41fe5f03112","type":"inject","z":"527caf4af9e659ad","name":"Start Measurement","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"HenrysRPi1/TCReadings","payloadType":"date","x":130,"y":200,"wires":[["f601edf621dacc74"]]},{"id":"f601edf621dacc74","type":"function","z":"527caf4af9e659ad","name":"Read TC Temps","func":"// Commands for Thermocouple amplifier (MAX31856)\n\nconst CR0=0x00;\nconst CR1=0x01;\nconst MASK=0x02;\nconst CJHF=0x03;\nconst CJLF=0x04;\nconst LTHFTH=0x05;\nconst LTHFTL=0x06;\nconst LTLFTH=0x07;\nconst LTLFTL=0x08;\nconst CJTO=0x09;\nconst CJTH=0x0A;\nconst CJTL=0x0B;\nconst LTCBH=0x0C;\nconst LTCBM=0x0D;\nconst LTCBL=0x0E;\nconst SR=0x0F;\n\n// CR0\n// CMODE 1SHOT OCFAULT1 OCFAULT0 CJ FAULT FAULTCLR 50/60Hz\nconst CMODE_OFF \t= 0b00000000;\nconst CMODE_AUTO \t= 0b10000000;\nconst ONESHOT\t\t= 0b01000000;\nconst OCFAULT_DISABLE = 0b00000000;\nconst OCFAULT_ENLT5 \t= 0b00010000;\nconst OCFAULT_EN40LT2 = 0b00100000;\nconst OCFAULT_EN40GT2 = 0b00110000;\nconst CJDISABLE \t= 0b00001000;\nconst FAULTINT = 0b00000100;\nconst FAULTCLR = 0b00000010;\nconst NR50HZ = 0b00000001;\nconst NR60HZ = 0b00000000;\n\n// CR1\n// Reserved AVGSEL 2 AVGSEL 1 AVGSEL 0 TC TYPE 3 TC TYPE 2 TC TYPE 1 TC TYPE 0\nconst SAMP_1\t\t= 0b00000000;\nconst SAMP_2\t\t= 0b00010000;\nconst SAMP_4\t\t= 0b00100000;\nconst SAMP_8\t\t= 0b00110000;\nconst SAMP_16\t\t= 0b01000000;\n\nconst VMODEGN8\t= 0b00001000;\nconst VMODEGN16\t= 0b00001100;\n\n// MASK\nconst OPNFLTMSK\t= 0b00111100;\n\n// Useful Parameters\nconst ERRTEMP\t\t= -6666;\n\n// Importing already setup varibles and libs\n\n\nconst TCAmp = context.get('TCAmp');\n\nconst fault = context.get('fault');\nconst ready = context.get('ready');\nconst mux1En = context.get('mux1En');\nconst mux2En = context.get('mux2En');\nconst muxA0 = context.get('muxA0');\nconst muxA1 = context.get('muxA1');\nconst muxA2 = context.get('muxA2');\n\nconst readreg = context.get('readreg');\nconst writereg = context.get('writereg');\nconst getTemp = context.get('getTemp');\nconst getCjTemp = context.get('getCjTemp');\n\nconst channel_status = context.get('channel_status');\nconst channel_type = context.get('channel_type');\n\n\n/******************************************************************************\n* This next section is \n* an adaptation of the TCtempconvert.py file.\n******************************************************************************/\n\nfunction convertToCel(tempBuffer) {\n    const sign = -1 * Number(!!(tempBuffer[1] & 1 << 7)) + Number(!(tempBuffer[1] & 1 << 7));\n    const HighByte = (tempBuffer[1] & 0b01111111) << 4;\n    const MidByte = tempBuffer[2]*Math.pow(2, -4);\n    const LowByte = (tempBuffer[3] & 0b11100000)*Math.pow(2, -12);\n\n    // node.warn(`Sign ${sign} High Byte ${HighByte} Mid Byte ${MidByte} Low Byte ${LowByte}`);\n\n    return sign*(HighByte + MidByte + LowByte);\n}\n\n\nfunction convertCjToCel(tempBuffer){\n    const sign = -1 * Number(!!(tempBuffer[1] & 1 << 7)) + Number(!(tempBuffer[1] & 1 << 7));\n    const HighByte = tempBuffer[1] & 0b01111111;\n    const LowByte = tempBuffer[2]*Math.pow(2, -8);\n\n    // node.warn(`Sign ${sign} High Byte ${HighByte} Low Byte ${LowByte}`);\n\n    return sign*(HighByte + LowByte);\n}\n\n\n/******************************************************************************\n*   \n******************************************************************************/\n\nfunction setMuxAddr(channel) {\n    var address = channel & 0x0F;\n    // use the leading digit to determine weather the channel \n    // is on the first or second mux\n    // Number casts?:  The authors of onoff decied that write command should \n    // only accept number type and interpret everything else as 0 without \n    // throwing and error.\n    mux1En.writeSync(Number(!(address & (1 << 3))));\n    mux2En.writeSync(Number(!!(address & (1 << 3))));\n\n    // node.warn(`Set the Mux to ${mux2En.readSync()} ${mux1En.readSync()}`);\n    // node.warn(`Should be ${!!(address & (1 << 3))} ${!(address & (1 << 3))}`);\n    // now using the least sigificant bits to get the mux input bits\n    muxA2.writeSync(Number(!!(address & (1 << 2))));\n    muxA1.writeSync(Number(!!(address & (1 << 1))));\n    muxA0.writeSync(Number(!!(address & 1)));\n    // node.warn(`Set the Mux Address to ${muxA2.readSync()} ${muxA1.readSync()} ${muxA0.readSync()}`)\n}\n\n\nfunction sleep(ms) {\n    return new Promise((accept, reject) => setTimeout(accept, ms));\n}\n\nasync function aquireTemps() {\n    var temps = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n    var faultCodes = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n    for (let channel = 0; channel < 17; channel++){\n        // node.warn(`Checking channel ${channel+1}`);\n        if(channel == 16) {\n            const cjresult = getCjTemp();\n            temps[channel] = convertCjToCel(cjresult);\n        } else {\n            if(channel_status[channel]){\n                const current_tctype = channel_type[channel];\n                setMuxAddr(channel);\n                await sleep(10);\n                writereg(CR1, SAMP_1 | current_tctype);\n                writereg(CR0, ONESHOT | OCFAULT_ENLT5 | NR60HZ);\n                await sleep(10);\n                var waitnum = 0;\n                // node.warn(`Started waiting for temp ${channel} for the ${waitnum}`);\n                while(ready.readSync() && waitnum < 100) {\n                    // node.warn(`Started waiting for temp ${channel} for the ${waitnum}`);\n                    // node.warn(ready.readSync());\n                    waitnum++;\n                    await sleep(10);\n                }\n                \n                if(waitnum >= 200) {\n                    temps[channel] = ERRTEMP;\n                    faultCodes[channel] = 1 << 8;\n                    node.error(\"The thermocouple amplifier timeout, it took more than a second to respond. [no code]\");\n                } else {\n                    const tempRslt  = getTemp();\n                    if(fault.readSync()){\n                        temps[channel] = convertToCel(tempRslt);\n                    } else {\n                        node.error(`Channel ${channel + 1} Fault!!`);\n                        const rslt  = readreg(SR);\n                        node.error(`Fault code ${Number(rslt).toString(16)}`);\n                        faultCodes[channel] = Number(rslt);\n                        if(rslt & 0b00000001){\n                            node.error(\"The thermocouple is disconnected. [OPEN]\");\n                        } else if(rslt & 0b00000010) {\n                            node.error(\"The TC amplifier is not getting the correct supply voltage. (Under/Over Voltage Fault) [OVUV]\");\n                        } else {\n                            node.error(\"Temp range error\");\n                        }\n                        temps[channel] = ERRTEMP;\n                    }\n                    \n                    // node.warn(`Channel ${channel} output ${rslt.toString('hex')}`);\n                }\n            }\n        }\n    }\n    // node.warn(temps)\n    return { temps, faultCodes };\n}\n\nconst { temps, faultCodes } = await aquireTemps();\n\n// node.warn(`${temps} \\n ${faultCodes}`);\n\nfunction formatDataMqttPacket(channel_status, temps, faultCodes) {\n    var data = {};\n    \n    for(var channel = 0; channel < 16; channel++){\n        if(channel_status[channel]) {\n            data[`TC${channel}`] = {\n                temp: temps[channel],\n                fault: faultCodes[channel],\n            }\n        }\n    }\n    \n    data[\"CJ\"] = {\n        temp: temps[16]\n    }\n    \n    data.timestamp = (new Date()).getTime();\n    \n    return { payload: {data, topic:msg.topic} }\n}\n\n\nfunction formatFaultMqttPacket(faultCodes) {\n    return {payload:{}}\n}\n\nif(faultCodes.reduce((acc, curr) => acc | curr, false)) {\n    node.send([formatDataMqttPacket(channel_status, temps, faultCodes), formatFaultMqttPacket(faultCodes)]);\n} else {\n    node.send([formatDataMqttPacket(channel_status, temps, faultCodes)])\n}","outputs":2,"noerr":0,"initialize":"/**-----------------------------------------------------------------------------\n*  This was converted from the TCRead.py project by PiPlay.\n*  I, Henry Hunt, adapted this for the MAGIS 100 project.\n*  with the perpose of controling heating during the vaccum \n*  bake.\n* \n*  This first section defines constants related to the PiPlay \n*  v1.3 board originally in the TC.py file.\n*-----------------------------------------------------------------------------**/\n// Commands for Thermocouple amplifier (MAX31856)\n\nconst CR0=0x00;\nconst CR1=0x01;\nconst MASK=0x02;\nconst CJHF=0x03;\nconst CJLF=0x04;\nconst LTHFTH=0x05;\nconst LTHFTL=0x06;\nconst LTLFTH=0x07;\nconst LTLFTL=0x08;\nconst CJTO=0x09;\nconst CJTH=0x0A;\nconst CJTL=0x0B;\nconst LTCBH=0x0C;\nconst LTCBM=0x0D;\nconst LTCBL=0x0E;\nconst SR=0x0F;\n\n// Mux Addressing\nconst MUX1_EN_PIN_NUM = 6;\nconst MUX2_EN_PIN_NUM = 12;\n\nconst MUX_A0_PIN_NUM = 19;\nconst MUX_A1_PIN_NUM = 20;\nconst MUX_A2_PIN_NUM = 21;\n\nconst FAULT_PIN_NUM = 13;\nconst READY_PIN_NUM = 5;\n\n// Thermocouple Type Codes\nconst TYPE_B \t\t= 0b00000000;\nconst TYPE_E\t\t= 0b00000001;\nconst TYPE_J\t\t= 0b00000010;\nconst TYPE_K\t\t= 0b00000011;\nconst TYPE_N\t\t= 0b00000100;\nconst TYPE_R\t\t= 0b00000101;\nconst TYPE_S\t\t= 0b00000110;\nconst TYPE_T\t\t= 0b00000111;\n\n// MASK\nconst OPNFLTMSK\t= 0b00111100;\n\n/******************************************************************************\n * This next section setup the context for the tempature reading\n * including the SPI and GPIO interfaces for the TCAmp and MUX \n * pins respectively.\n * \n * It is not directly parallel to any of the code in TCRead.py,\n * but the TCRead.py function setupcommscontains the most simlar \n * content.\n ******************************************************************************/\n\nconst spi = global.get(\"spi\");\nconst Gpio = global.get(\"Gpio\");\n\nnode.log(\"Starting up tempurature measurement.\");\n\nconst TCAmp = spi.openSync(0,0, {mode: spi.MODE1, maxSpeedHz:7629}); // The SPI interface for the TC amp\ncontext.set('TCAmp', TCAmp);\n\nconst fault = new Gpio(FAULT_PIN_NUM, 'in');\nconst ready = new Gpio(READY_PIN_NUM, 'in');\nconst mux1En = new Gpio(MUX1_EN_PIN_NUM, 'out');\nconst mux2En = new Gpio(MUX2_EN_PIN_NUM, 'out');\nconst muxA0 = new Gpio(MUX_A0_PIN_NUM, 'out');\nconst muxA1 = new Gpio(MUX_A1_PIN_NUM, 'out');\nconst muxA2 = new Gpio(MUX_A2_PIN_NUM, 'out');\n\n\ncontext.set('fault', fault);\ncontext.set('ready', ready);\ncontext.set('mux1En', mux1En);\ncontext.set('mux2En', mux2En);\ncontext.set('muxA0', muxA0);\ncontext.set('muxA1', muxA1);\ncontext.set('muxA2', muxA2);\n\n/******************************************************************************\n* This next section is an adaptation of the TCspi.py file.  \n* \n* It creates functions which simiplify the SPI interaction \n* with the TCAmp.\n******************************************************************************/\n\nfunction readreg(command){ // command: byte\n    const msg = [{\n        sendBuffer: Buffer.from([command, 0x00]),\n        byteLength: 2,\n        receiveBuffer: Buffer.alloc(2)\n    }];\n    \n    TCAmp.transferSync(msg);\n    \n    return msg[0].receiveBuffer[1];\n}\n\nfunction writereg(command, writeval){\n    const fullCmd = command | 0x80; // setting penultimate bit high???\n    const msg = [{\n        sendBuffer: Buffer.from([fullCmd, writeval]),\n        byteLength: 2\n    }];\n    \n    TCAmp.transferSync(msg);\n    \n    // node.warn(msg);\n    \n    return;\n}\n\nfunction getTemp(){\n    const msg = [{\n        sendBuffer: Buffer.from([LTCBH, 0x00, 0x00, 0x00]),\n        byteLength: 4,\n        receiveBuffer: Buffer.alloc(4)\n    }];\n    \n    TCAmp.transferSync(msg);\n    \n    // node.warn(msg);\n    \n    return msg[0].receiveBuffer;\n}\n\nfunction getCjTemp(){\n    const msg = [{\n        sendBuffer: Buffer.from([CJTH, 0x00, 0x00]),\n        byteLength: 3,\n        receiveBuffer: Buffer.alloc(3)\n    }];\n    \n    TCAmp.transferSync(msg);\n    \n    // node.warn(msg);\n    \n    return msg[0].receiveBuffer;\n}\n\ncontext.set('readreg', readreg);\ncontext.set('writereg', writereg);\ncontext.set('getTemp', getTemp);\ncontext.set('getCjTemp', getCjTemp);\n\nwritereg(MASK, OPNFLTMSK);\n\n// Initial setup of thermocouple channels\n\nvar channel_status = [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false];\nvar channel_type = [TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K];\n\n// wait for the settings to get defined\n\nawait new Promise(acc => setTimeout(acc, 100))\n\nif(!global.get(\"TCSettings\"))\n        throw 'The thermocouple settings object is missing from global context.'\n\nconst TCSettings = global.get(\"TCSettings\");\n\nfor(var i = 0; i < TCSettings.length; i++){\n    const channelObj = TCSettings[i][0]; // I have no clue why but \n    // using global context transform objects into arrays \n    // with one entry containing the object.\n    const channel = channelObj.channel;\n   \n    channel_status[channel] = channelObj.onoff;\n    switch(channelObj.type){\n        case 'TYPE_B':\n            channel_type[channel] = TYPE_B;\n            break;\n        case 'TYPE_E':\n            channel_type[channel] = TYPE_E;\n            break;\n        case 'TYPE_J':\n            channel_type[channel] = TYPE_J;\n            break;\n        case 'TYPE_K':\n            channel_type[channel] = TYPE_K;\n            break;\n        case 'TYPE_N':\n            channel_type[channel] = TYPE_N;\n            break;\n        case 'TYPE_R':\n            channel_type[channel] = TYPE_R;\n            break;\n        case 'TYPE_S':\n            channel_type[channel] = TYPE_S;\n            break;\n        case 'TYPE_T':\n            channel_type[channel] = TYPE_T;\n            break;\n        default:\n            throw `TCSettings.json contains invalid channel type for channel ${channel} namely ${channelObj.type}`;\n    }\n}\nnode.log(\"Channel Statuses: \", channel_status);\nnode.log(\"Channel Types: \", channel_type);\n\n\ncontext.set('channel_status', channel_status);\ncontext.set('channel_type', channel_type);","finalize":"// Code added here will be run when the\n// node is being stopped or re-deployed.\n\ncontext.get('TCAmp').closeSync();\n\ncontext.get('fault').unexport();\ncontext.get('ready').unexport();\ncontext.get('mux1En').unexport();\ncontext.get('mux2En').unexport();\ncontext.get('muxA0').unexport();\ncontext.get('muxA1').unexport();\ncontext.get('muxA2').unexport();","libs":[],"x":400,"y":200,"wires":[["2be9542b7321ca7e","9d64142eca7957ad"],[]]},{"id":"2ec449b0e7b67043","type":"debug","z":"527caf4af9e659ad","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":530,"y":300,"wires":[]},{"id":"b92d775d460d1a74","type":"file in","z":"527caf4af9e659ad","name":"Thermocouple Settings","filename":"TCSettings.json","format":"utf8","chunk":false,"sendError":false,"encoding":"none","allProps":false,"x":370,"y":40,"wires":[["13f25e7a53365a72"]]},{"id":"13f25e7a53365a72","type":"function","z":"527caf4af9e659ad","name":"Load TC Settings","func":"if(typeof msg.payload !== 'string')\n    throw 'TCSettings.json File read didn\\'t return a string';\n    \nvar SettingsObj = {};\n\ntry{\n    SettingsObj = JSON.parse(msg.payload);\n} catch (e) {\n    node.error(\"I ran into an error while trying to parse TCSettings.json\");\n    throw e;\n}\n\nif(!SettingsObj.TCSettings)\n    throw 'TCSettings.json doesn\\'t contain the TCSettings array';\n    \nif(!Array.isArray(SettingsObj.TCSettings))\n    throw `TCSettings must be an array not a ${typeof SettingsObj.TCSettings}`;\n\n// node.warn(SettingsObj.TCSettings)\n    \nglobal.set(\"TCSettings\", SettingsObj.TCSettings);\n\nreturn SettingsObj.TCSettings;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":690,"y":40,"wires":[[]]},{"id":"9ef1cea07e5dcd58","type":"inject","z":"527caf4af9e659ad","name":"Read Settings","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":"0.0","topic":"TCSettings","payloadType":"date","x":120,"y":40,"wires":[["b92d775d460d1a74"]]},{"id":"c361e42c0ed2a80b","type":"tcp in","z":"527caf4af9e659ad","name":"","server":"server","host":"","port":"3456","datamode":"stream","datatype":"utf8","newline":"","topic":"","base64":false,"x":60,"y":720,"wires":[["ddc6c97fa4f12c78","93562e6e1e7d225b","7f581d80fa9ac110","3d914ce2a4f1390a","426ae065e5b0101f","69e14f169d6806ca","31ff8d26936f54ae","2c59ce803bc21c58","a05bd7747418d36f","d8ec3780d297ce07"]]},{"id":"ddc6c97fa4f12c78","type":"function","z":"527caf4af9e659ad","name":"TC0 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST1', msg1.data.TC0.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":380,"wires":[[]]},{"id":"de6f3a2efd9054c8","type":"xmlrpc call","z":"527caf4af9e659ad","name":"ACNET setting","method":"Remote.setting","client":"c73f1334ec7ae6a9","x":620,"y":700,"wires":[[]]},{"id":"93562e6e1e7d225b","type":"function","z":"527caf4af9e659ad","name":"TC1 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST2', msg1.data.TC1.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":440,"wires":[[]]},{"id":"23c9fc0bdb856ad4","type":"xmlrpc call","z":"527caf4af9e659ad","name":"ACNET setting","method":"Remote.setting","client":"c73f1334ec7ae6a9","x":640,"y":360,"wires":[[]]},{"id":"87759036efdb9d30","type":"function","z":"527caf4af9e659ad","name":"","func":"var currentTempsString = '\\n';\nfor (var i = 0; i < 8; i++){\n    currentTempsString += `Temp ${i+1}: ${msg.payload.data[`TC${i}`].temp}\\n`\n   node.send({topic:`temp ${i+1}`, payload: msg.payload.data[`TC${i}`].temp}) \n}\n\n// node.warn(currentTempsString)","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":200,"wires":[["d75365ca45e6b136"]]},{"id":"2be9542b7321ca7e","type":"json","z":"527caf4af9e659ad","name":"","property":"payload","action":"","pretty":false,"x":590,"y":120,"wires":[["2ec449b0e7b67043"]]},{"id":"9d64142eca7957ad","type":"function","z":"527caf4af9e659ad","name":"Restart Measurement","func":"lastTime = context.get(\"lastTime\")\n\nvar cycleTime = null;\n\nif(!lastTime){\n    context.set(\"lastTime\", Date.now())\n} else {\n    timeNow = Date.now()\n    cycleTime = timeNow - lastTime\n    context.set(\"lastTime\", timeNow)\n}\n\nnode.warn(`Cycle restarted: ${cycleTime/1000} seconds`)\n\nreturn {payload:{cycleTime}};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":340,"y":120,"wires":[["f601edf621dacc74"]]},{"id":"7f581d80fa9ac110","type":"function","z":"527caf4af9e659ad","name":"TC2 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST3', msg1.data.TC2.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":500,"wires":[[]]},{"id":"3d914ce2a4f1390a","type":"function","z":"527caf4af9e659ad","name":"TC3 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST4', msg1.data.TC3.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":560,"wires":[[]]},{"id":"426ae065e5b0101f","type":"function","z":"527caf4af9e659ad","name":"TC4 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST5', msg1.data.TC4.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":620,"wires":[[]]},{"id":"69e14f169d6806ca","type":"function","z":"527caf4af9e659ad","name":"TC5 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST6', msg1.data.TC4.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":680,"wires":[[]]},{"id":"31ff8d26936f54ae","type":"function","z":"527caf4af9e659ad","name":"TC6 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST7', msg1.data.TC6.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":740,"wires":[[]]},{"id":"2c59ce803bc21c58","type":"function","z":"527caf4af9e659ad","name":"TC7 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST8', msg1.data.TC7.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":800,"wires":[[]]},{"id":"d75365ca45e6b136","type":"ui_chart","z":"527caf4af9e659ad","name":"","group":"e0f52056.325bc","order":0,"width":0,"height":0,"label":"Tempurature Chart","chartType":"line","legend":"false","xformat":"HH:mm:ss","interpolate":"linear","nodata":"","dot":false,"ymin":"23","ymax":"","removeOlder":1,"removeOlderPoints":"","removeOlderUnit":"3600","cutout":0,"useOneColor":false,"useUTC":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"outputs":1,"useDifferentColor":false,"x":930,"y":200,"wires":[[]]},{"id":"50c96504f96e4785","type":"inject","z":"527caf4af9e659ad","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"[]","payloadType":"str","x":750,"y":260,"wires":[["d75365ca45e6b136"]]},{"id":"a05bd7747418d36f","type":"function","z":"527caf4af9e659ad","name":"TC8 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST9', msg1.data.TC8.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":860,"wires":[[]]},{"id":"d8ec3780d297ce07","type":"function","z":"527caf4af9e659ad","name":"TC9 temperature","func":"var msg1 = JSON.parse(msg.payload);\n\n\nreturn {payload: ['E:MAGIST10', msg1.data.TC9.temp]};","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":920,"wires":[[]]}]