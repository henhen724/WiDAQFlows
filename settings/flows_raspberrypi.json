[{"id":"527caf4af9e659ad","type":"tab","label":"Flow 1","disabled":false,"info":""},{"id":"e0f52056.325bc","type":"ui_group","name":"RPi Zero","tab":"3bec34ab.c27f4c","order":1,"disp":true,"width":"6","collapse":false},{"id":"8e661657.472578","type":"mqtt-broker","name":"Controls server","broker":"beam.uchicago.edu","port":"1883","clientid":"","usetls":false,"compatmode":false,"protocolVersion":"4","keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willPayload":"","willMsg":{},"sessionExpiry":""},{"id":"3bec34ab.c27f4c","type":"ui_tab","name":"Home","icon":"dashboard","disabled":false,"hidden":false},{"id":"dabdd185.14c78","type":"serial-port","serialport":"/dev/rfcomm0","serialbaud":"9600","databits":"8","parity":"none","stopbits":"1","waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\n","bin":"false","out":"char","addchar":"","responsetimeout":"10000"},{"id":"cb445b81.34d848","type":"ui_base","theme":{"name":"theme-light","lightTheme":{"default":"#0094CE","baseColor":"#0094CE","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"darkTheme":{"default":"#097479","baseColor":"#097479","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":false},"customTheme":{"name":"Untitled Theme 1","default":"#4B7930","baseColor":"#4B7930","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"},"themeState":{"base-color":{"default":"#0094CE","value":"#0094CE","edited":false},"page-titlebar-backgroundColor":{"value":"#0094CE","edited":false},"page-backgroundColor":{"value":"#fafafa","edited":false},"page-sidebar-backgroundColor":{"value":"#ffffff","edited":false},"group-textColor":{"value":"#1bbfff","edited":false},"group-borderColor":{"value":"#ffffff","edited":false},"group-backgroundColor":{"value":"#ffffff","edited":false},"widget-textColor":{"value":"#111111","edited":false},"widget-backgroundColor":{"value":"#0094ce","edited":false},"widget-borderColor":{"value":"#ffffff","edited":false},"base-font":{"value":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"}},"angularTheme":{"primary":"indigo","accents":"blue","warn":"red","background":"grey"}},"site":{"name":"Node-RED Dashboard","hideToolbar":"false","allowSwipe":"false","lockMenu":"false","allowTempTheme":"true","dateFormat":"DD/MM/YYYY","sizes":{"sx":48,"sy":48,"gx":6,"gy":6,"cx":6,"cy":6,"px":0,"py":0}}},{"id":"44644766.155948","type":"serial-port","serialport":"/dev/rfcomm1","serialbaud":"9600","databits":"8","parity":"none","stopbits":"1","waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\n","bin":"false","out":"char","addchar":"","responsetimeout":"10000"},{"id":"36bfa41fe5f03112","type":"inject","z":"527caf4af9e659ad","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payloadType":"date","x":220,"y":240,"wires":[["f601edf621dacc74"]]},{"id":"f601edf621dacc74","type":"function","z":"527caf4af9e659ad","name":"Read TC Temps","func":"// Commands for Thermocouple amplifier (MAX31856)\n\nconst CR0=0x00;\nconst CR1=0x01;\nconst MASK=0x02;\nconst CJHF=0x03;\nconst CJLF=0x04;\nconst LTHFTH=0x05;\nconst LTHFTL=0x06;\nconst LTLFTH=0x07;\nconst LTLFTL=0x08;\nconst CJTO=0x09;\nconst CJTH=0x0A;\nconst CJTL=0x0B;\nconst LTCBH=0x0C;\nconst LTCBM=0x0D;\nconst LTCBL=0x0E;\nconst SR=0x0F;\n\n// Temperature conversion parameters.\n\nconst MAX31856_CONST_THERM_BITS = 19;\nconst MAX31856_CONST_THERM_LSB = 2**-7;\nconst MAX31856_CONST_CJ_BITS = 14;\nconst MAX31856_CONST_CJ_LSB = 2**-6;\n\n\n// Register Settings\n\n// CR0\n// CMODE 1SHOT OCFAULT1 OCFAULT0 CJ FAULT FAULTCLR 50/60Hz\nconst CMODE_OFF \t= 0b00000000;\nconst CMODE_AUTO \t= 0b10000000;\nconst ONESHOT\t\t= 0b01000000;\nconst OCFAULT_DISABLE = 0b00000000;\nconst OCFAULT_ENLT5 \t= 0b00010000;\nconst OCFAULT_EN40LT2 = 0b00100000;\nconst OCFAULT_EN40GT2 = 0b00110000;\nconst CJDISABLE \t= 0b00001000;\nconst FAULTINT = 0b00000100;\nconst FAULTCLR = 0b00000010;\nconst NR50HZ = 0b00000001;\nconst NR60HZ = 0b00000000;\n\n// CR1\n// Reserved AVGSEL 2 AVGSEL 1 AVGSEL 0 TC TYPE 3 TC TYPE 2 TC TYPE 1 TC TYPE 0\n\nconst SAMP_1\t\t= 0b00000000;\nconst SAMP_2\t\t= 0b00010000;\nconst SAMP_4\t\t= 0b00100000;\nconst SAMP_8\t\t= 0b00110000;\nconst SAMP_16\t\t= 0b01000000;\n\nconst VMODEGN8\t= 0b00001000;\nconst VMODEGN16\t= 0b00001100;\n\n// MASK\nconst OPNFLTMSK\t= 0b00111100;\n\n// Useful Parameters\nconst ERRTEMP\t\t= -6666;\n\n// Importing already setup varibles and libs\n\n\nconst TCAmp = context.get('TCAmp');\n\nconst fault = context.get('fault');\nconst ready = context.get('ready');\nconst mux1En = context.get('mux1En');\nconst mux2En = context.get('mux2En');\nconst muxA0 = context.get('muxA0');\nconst muxA1 = context.get('muxA1');\nconst muxA2 = context.get('muxA2');\n\nconst readreg = context.get('readreg');\nconst writereg = context.get('writereg');\nconst getTemp = context.get('getTemp');\nconst getCjTemp = context.get('getCjTemp');\n\nconst channel_status = context.get('channel_status');\nconst channel_type = context.get('channel_type');\n\n\n/******************************************************************************\n* This next section is an adaptation of the TCtempconvert.py file.\n* \n* \n******************************************************************************/\n\nfunction convertToCel(tempBuffer){\n    \n}\n\nfunction convertCjToCel(tempBuffer){\n    \n}\n\n/******************************************************************************\n*   \n******************************************************************************/\n\nfunction setMuxAddr(channel) {\n    var address = channel & 0x0F;\n    // use the leading digit to determine weather the channel \n    // is on the first or second mux\n    mux1En.writeSync(!(address & (1 << 3)));\n    mux2En.writeSync(!!(address & (1 << 3)));\n    \n    // now using the least sigificant bits to get the mux input bits\n    muxA2.writeSync(!!(address & (1 << 2)));\n    muxA1.writeSync(!!(address & (1 << 1)));\n    muxA0.writeSync(!!(address & 1));\n}\n\nfunction sleep(ms) {\n    return new Promise((accept, reject) => setTimeout(accept, ms));\n}\n\nasync function aquireTemps() {\n    var temps = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    for (let channel = 0; channel < 17; channel++){\n        node.warn(`Checking channel ${channel+1}`);\n        if(channel == 16) {\n            const cjresult = getCjTemp();\n            // node.warn(`Cold Junction Temp Rslt \\t ${cjresult.toString('hex')}`);\n            // const precjtemp = convert_cjtemps(cjresult[0], cjresult[1]);\n            temps[channel] = ERRTEMP;\n        } else {\n            if(channel_status[channel]){\n                const current_tctype = channel_type[channel];\n                writereg(CR1, SAMP_4 | current_tctype);\n                writereg(CR0, ONESHOT | OCFAULT_ENLT5 | NR60HZ);\n                \n                await sleep(10);\n                var waitnum = 0;\n                // node.warn(`Started waiting for temp ${channel} for the ${waitnum}`);\n                while(ready.readSync() && waitnum < 100) {\n                    // node.warn(`Started waiting for temp ${channel} for the ${waitnum}`);\n                    // node.warn(ready.readSync());\n                    waitnum++;\n                    await sleep(10);\n                }\n                const tempRslt  = getTemp();\n                if(fault.readSync()){\n                    temps[channel] = tempRslt[1];   \n                } else {\n                    node.error(`Channel ${channel + 1} Fault!!`);\n                    const rslt  = readreg(SR);\n                    node.error(`Fault code ${Number(rslt).toString(16)}`);\n                    if(rslt & 0b00000001){\n                        node.error(\"The thermocouple is disconnected. [OPEN]\");\n                    } else if(rslt & 0b00000010) {\n                        node.error(\"The TC amplifier is not getting the correct supply voltage. (Under/Over Voltage Fault) [OVUV]\");\n                    } else {\n                        node.error(\"Temp range error\");\n                    }\n                    temps[channel] = ERRTEMP;\n                }\n                \n                // node.warn(`Channel ${channel} output ${rslt.toString('hex')}`);\n            }\n        }\n    }\n    node.warn(temps)\n    return [];\n}\n\naquireTemps();\nreturn { error: false };","outputs":1,"noerr":0,"initialize":"/**-----------------------------------------------------------------------------\n*  This was converted from the TCRead.py project by PiPlay.\n*  I, Henry Hunt, adapted this for the MAGIS 100 project.\n*  with the perpose of controling heating during the vaccum \n*  bake.\n* \n*  This first section defines constants related to the PiPlay \n*  v1.3 board originally in the TC.py file.\n*-----------------------------------------------------------------------------**/\n// Commands for Thermocouple amplifier (MAX31856)\n\nconst CR0=0x00;\nconst CR1=0x01;\nconst MASK=0x02;\nconst CJHF=0x03;\nconst CJLF=0x04;\nconst LTHFTH=0x05;\nconst LTHFTL=0x06;\nconst LTLFTH=0x07;\nconst LTLFTL=0x08;\nconst CJTO=0x09;\nconst CJTH=0x0A;\nconst CJTL=0x0B;\nconst LTCBH=0x0C;\nconst LTCBM=0x0D;\nconst LTCBL=0x0E;\nconst SR=0x0F;\n\n// Mux Addressing\nconst MUX1_EN_PIN_NUM = 6;\nconst MUX2_EN_PIN_NUM = 12;\n\nconst MUX_A0_PIN_NUM = 19;\nconst MUX_A1_PIN_NUM = 20;\nconst MUX_A2_PIN_NUM = 21;\n\nconst FAULT_PIN_NUM = 13;\nconst READY_PIN_NUM = 5;\n\n// Thermocouple Type Codes\nconst TYPE_B \t\t= 0b00000000;\nconst TYPE_E\t\t= 0b00000001;\nconst TYPE_J\t\t= 0b00000010;\nconst TYPE_K\t\t= 0b00000011;\nconst TYPE_N\t\t= 0b00000100;\nconst TYPE_R\t\t= 0b00000101;\nconst TYPE_S\t\t= 0b00000110;\nconst TYPE_T\t\t= 0b00000111;\n\n// MASK\nconst OPNFLTMSK\t= 0b00111100;\n\n/******************************************************************************\n * This next section setup the context for the tempature reading\n * including the SPI and GPIO interfaces for the TCAmp and MUX \n * pins respectively.\n * \n * It is not directly parallel to any of the code in TCRead.py,\n * but the TCRead.py function setupcommscontains the most simlar \n * content.\n ******************************************************************************/\n\nconst spi = global.get(\"spi\");\nconst Gpio = global.get(\"Gpio\");\n\nnode.log(\"Starting up tempurature measurement.\");\n\nconst TCAmp = spi.openSync(0,0, {mode: spi.MODE1, maxSpeedHz:7629}); // The SPI interface for the TC amp\ncontext.set('TCAmp', TCAmp);\n\nconst fault = new Gpio(FAULT_PIN_NUM, 'in');\nconst ready = new Gpio(READY_PIN_NUM, 'in');\nconst mux1En = new Gpio(MUX1_EN_PIN_NUM, 'out');\nconst mux2En = new Gpio(MUX2_EN_PIN_NUM, 'out');\nconst muxA0 = new Gpio(MUX_A0_PIN_NUM, 'out');\nconst muxA1 = new Gpio(MUX_A1_PIN_NUM, 'out');\nconst muxA2 = new Gpio(MUX_A2_PIN_NUM, 'out');\n\n\ncontext.set('fault', fault);\ncontext.set('ready', ready);\ncontext.set('mux1En', mux1En);\ncontext.set('mux2En', mux2En);\ncontext.set('muxA0', muxA0);\ncontext.set('muxA1', muxA1);\ncontext.set('muxA2', muxA2);\n\n/******************************************************************************\n* This next section is an adaptation of the TCspi.py file.  \n* \n* It creates functions which simiplify the SPI interaction \n* with the TCAmp.\n******************************************************************************/\n\nfunction readreg(command){ // command: byte\n    const msg = [{\n        sendBuffer: Buffer.from([command, 0x00]),\n        byteLength: 2,\n        receiveBuffer: Buffer.alloc(2)\n    }];\n    TCAmp.transferSync(msg);\n    return msg[0].receiveBuffer[1];\n}\n\nfunction writereg(command, writeval){\n    const fullCmd = command | 0x80; // setting penultimate bit high???\n    const msg = [{\n        sendBuffer: Buffer.from([fullCmd, writeval]),\n        byteLength: 2\n    }];\n    TCAmp.transferSync(msg);\n    \n    // node.warn(msg);\n    return;\n}\n\nfunction getTemp(){\n    const msg = [{\n        sendBuffer: Buffer.from([LTCBH, 0x00, 0x00, 0x00]),\n        byteLength: 4,\n        recieveBuffer: Buffer.alloc(4)\n    }];\n    TCAmp.transferSync(msg);\n    \n    node.warn(msg);\n    \n    return msg[0].receiveBuffer;\n}\n\nfunction getCjTemp(){\n    const msg = [{\n        sendBuffer: Buffer.from([CJTH, 0x00, 0x00]),\n        byteLength: 3,\n        recieveBuffer: Buffer.alloc(3)\n    }];\n    TCAmp.transferSync(msg);\n    node.warn(msg);\n    return msg[0].receiveBuffer;\n}\n\ncontext.set('readreg', readreg);\ncontext.set('writereg', writereg);\ncontext.set('getTemp', getTemp);\ncontext.set('getCjTemp', getCjTemp);\n\nwritereg(MASK, OPNFLTMSK);\n\n// Initial setup of thermocouple channels\n\nvar channel_status = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar channel_type = [TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K, TYPE_K];\n\nfor (var channel = 0; channel < 17; channel++){\n    store_setup(channel);\n}\n\nfunction store_setup(channel) {\n    channel_status[channel] = 1;\n    channel_type[channel] = TYPE_K;\n}\n\ncontext.set('channel_status', channel_status);\ncontext.set('channel_type', channel_type);","finalize":"// Code added here will be run when the\n// node is being stopped or re-deployed.\n\ncontext.get('TCAmp').closeSync();\n\ncontext.get('fault').unexport();\ncontext.get('ready').unexport();\ncontext.get('mux1En').unexport();\ncontext.get('mux2En').unexport();\ncontext.get('muxA0').unexport();\ncontext.get('muxA1').unexport();\ncontext.get('muxA2').unexport();","libs":[],"x":520,"y":240,"wires":[[]]}]